"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAuthenticationHandler = getAuthenticationHandler;

var _common = require("../../common");

var _types = require("./types");

/*
 *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License").
 *   You may not use this file except in compliance with the License.
 *   A copy of the License is located at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   or in the "license" file accompanying this file. This file is distributed
 *   on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied. See the License for the specific language governing
 *   permissions and limitations under the License.
 */
function createAuthentication(ctor, config, sessionStorageFactory, router, esClient, coreSetup, logger) {
  return new ctor(config, sessionStorageFactory, router, esClient, coreSetup, logger);
}

function getAuthenticationHandler(authType, router, config, core, esClient, securitySessionStorageFactory, logger) {
  let authHandlerType;

  switch (authType) {
    case '':
    case 'basicauth':
      authHandlerType = _types.BasicAuthentication;
      break;

    case _common.AuthType.JWT:
      authHandlerType = _types.JwtAuthentication;
      break;

    case _common.AuthType.OPEN_ID:
      authHandlerType = _types.OpenIdAuthentication;
      break;

    case _common.AuthType.SAML:
      authHandlerType = _types.SamlAuthentication;
      break;

    case _common.AuthType.PROXY:
      authHandlerType = _types.ProxyAuthentication;
      break;

    default:
      throw new Error(`Unsupported authentication type: ${authType}`);
  }

  const auth = createAuthentication(authHandlerType, config, securitySessionStorageFactory, router, esClient, core, logger);
  return auth;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImF1dGhfaGFuZGxlcl9mYWN0b3J5LnRzIl0sIm5hbWVzIjpbImNyZWF0ZUF1dGhlbnRpY2F0aW9uIiwiY3RvciIsImNvbmZpZyIsInNlc3Npb25TdG9yYWdlRmFjdG9yeSIsInJvdXRlciIsImVzQ2xpZW50IiwiY29yZVNldHVwIiwibG9nZ2VyIiwiZ2V0QXV0aGVudGljYXRpb25IYW5kbGVyIiwiYXV0aFR5cGUiLCJjb3JlIiwic2VjdXJpdHlTZXNzaW9uU3RvcmFnZUZhY3RvcnkiLCJhdXRoSGFuZGxlclR5cGUiLCJCYXNpY0F1dGhlbnRpY2F0aW9uIiwiQXV0aFR5cGUiLCJKV1QiLCJKd3RBdXRoZW50aWNhdGlvbiIsIk9QRU5fSUQiLCJPcGVuSWRBdXRoZW50aWNhdGlvbiIsIlNBTUwiLCJTYW1sQXV0aGVudGljYXRpb24iLCJQUk9YWSIsIlByb3h5QXV0aGVudGljYXRpb24iLCJFcnJvciIsImF1dGgiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFzQkE7O0FBQ0E7O0FBdkJBOzs7Ozs7Ozs7Ozs7OztBQWtDQSxTQUFTQSxvQkFBVCxDQUNFQyxJQURGLEVBRUVDLE1BRkYsRUFHRUMscUJBSEYsRUFJRUMsTUFKRixFQUtFQyxRQUxGLEVBTUVDLFNBTkYsRUFPRUMsTUFQRixFQVF1QjtBQUNyQixTQUFPLElBQUlOLElBQUosQ0FBU0MsTUFBVCxFQUFpQkMscUJBQWpCLEVBQXdDQyxNQUF4QyxFQUFnREMsUUFBaEQsRUFBMERDLFNBQTFELEVBQXFFQyxNQUFyRSxDQUFQO0FBQ0Q7O0FBRU0sU0FBU0Msd0JBQVQsQ0FDTEMsUUFESyxFQUVMTCxNQUZLLEVBR0xGLE1BSEssRUFJTFEsSUFKSyxFQUtMTCxRQUxLLEVBTUxNLDZCQU5LLEVBT0xKLE1BUEssRUFRZ0I7QUFDckIsTUFBSUssZUFBSjs7QUFDQSxVQUFRSCxRQUFSO0FBQ0UsU0FBSyxFQUFMO0FBQ0EsU0FBSyxXQUFMO0FBQ0VHLE1BQUFBLGVBQWUsR0FBR0MsMEJBQWxCO0FBQ0E7O0FBQ0YsU0FBS0MsaUJBQVNDLEdBQWQ7QUFDRUgsTUFBQUEsZUFBZSxHQUFHSSx3QkFBbEI7QUFDQTs7QUFDRixTQUFLRixpQkFBU0csT0FBZDtBQUNFTCxNQUFBQSxlQUFlLEdBQUdNLDJCQUFsQjtBQUNBOztBQUNGLFNBQUtKLGlCQUFTSyxJQUFkO0FBQ0VQLE1BQUFBLGVBQWUsR0FBR1EseUJBQWxCO0FBQ0E7O0FBQ0YsU0FBS04saUJBQVNPLEtBQWQ7QUFDRVQsTUFBQUEsZUFBZSxHQUFHVSwwQkFBbEI7QUFDQTs7QUFDRjtBQUNFLFlBQU0sSUFBSUMsS0FBSixDQUFXLG9DQUFtQ2QsUUFBUyxFQUF2RCxDQUFOO0FBbEJKOztBQW9CQSxRQUFNZSxJQUF5QixHQUFHeEIsb0JBQW9CLENBQ3BEWSxlQURvRCxFQUVwRFYsTUFGb0QsRUFHcERTLDZCQUhvRCxFQUlwRFAsTUFKb0QsRUFLcERDLFFBTG9ELEVBTXBESyxJQU5vRCxFQU9wREgsTUFQb0QsQ0FBdEQ7QUFTQSxTQUFPaUIsSUFBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICAgQ29weXJpZ2h0IDIwMjAgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuXG4gKiAgIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICAgQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZFxuICogICBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqICAgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbiAqICAgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIElSb3V0ZXIsXG4gIENvcmVTZXR1cCxcbiAgSUxlZ2FjeUNsdXN0ZXJDbGllbnQsXG4gIExvZ2dlcixcbiAgU2Vzc2lvblN0b3JhZ2VGYWN0b3J5LFxufSBmcm9tICdraWJhbmEvc2VydmVyJztcbmltcG9ydCB7IEF1dGhUeXBlIH0gZnJvbSAnLi4vLi4vY29tbW9uJztcbmltcG9ydCB7XG4gIEJhc2ljQXV0aGVudGljYXRpb24sXG4gIEp3dEF1dGhlbnRpY2F0aW9uLFxuICBPcGVuSWRBdXRoZW50aWNhdGlvbixcbiAgUHJveHlBdXRoZW50aWNhdGlvbixcbiAgU2FtbEF1dGhlbnRpY2F0aW9uLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IFNlY3VyaXR5U2Vzc2lvbkNvb2tpZSB9IGZyb20gJy4uL3Nlc3Npb24vc2VjdXJpdHlfY29va2llJztcbmltcG9ydCB7IElBdXRoZW50aWNhdGlvblR5cGUsIElBdXRoSGFuZGxlckNvbnN0cnVjdG9yIH0gZnJvbSAnLi90eXBlcy9hdXRoZW50aWNhdGlvbl90eXBlJztcbmltcG9ydCB7IFNlY3VyaXR5UGx1Z2luQ29uZmlnVHlwZSB9IGZyb20gJy4uJztcblxuZnVuY3Rpb24gY3JlYXRlQXV0aGVudGljYXRpb24oXG4gIGN0b3I6IElBdXRoSGFuZGxlckNvbnN0cnVjdG9yLFxuICBjb25maWc6IFNlY3VyaXR5UGx1Z2luQ29uZmlnVHlwZSxcbiAgc2Vzc2lvblN0b3JhZ2VGYWN0b3J5OiBTZXNzaW9uU3RvcmFnZUZhY3Rvcnk8U2VjdXJpdHlTZXNzaW9uQ29va2llPixcbiAgcm91dGVyOiBJUm91dGVyLFxuICBlc0NsaWVudDogSUxlZ2FjeUNsdXN0ZXJDbGllbnQsXG4gIGNvcmVTZXR1cDogQ29yZVNldHVwLFxuICBsb2dnZXI6IExvZ2dlclxuKTogSUF1dGhlbnRpY2F0aW9uVHlwZSB7XG4gIHJldHVybiBuZXcgY3Rvcihjb25maWcsIHNlc3Npb25TdG9yYWdlRmFjdG9yeSwgcm91dGVyLCBlc0NsaWVudCwgY29yZVNldHVwLCBsb2dnZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXV0aGVudGljYXRpb25IYW5kbGVyKFxuICBhdXRoVHlwZTogc3RyaW5nLFxuICByb3V0ZXI6IElSb3V0ZXIsXG4gIGNvbmZpZzogU2VjdXJpdHlQbHVnaW5Db25maWdUeXBlLFxuICBjb3JlOiBDb3JlU2V0dXAsXG4gIGVzQ2xpZW50OiBJTGVnYWN5Q2x1c3RlckNsaWVudCxcbiAgc2VjdXJpdHlTZXNzaW9uU3RvcmFnZUZhY3Rvcnk6IFNlc3Npb25TdG9yYWdlRmFjdG9yeTxTZWN1cml0eVNlc3Npb25Db29raWU+LFxuICBsb2dnZXI6IExvZ2dlclxuKTogSUF1dGhlbnRpY2F0aW9uVHlwZSB7XG4gIGxldCBhdXRoSGFuZGxlclR5cGU6IElBdXRoSGFuZGxlckNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKGF1dGhUeXBlKSB7XG4gICAgY2FzZSAnJzpcbiAgICBjYXNlICdiYXNpY2F1dGgnOlxuICAgICAgYXV0aEhhbmRsZXJUeXBlID0gQmFzaWNBdXRoZW50aWNhdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQXV0aFR5cGUuSldUOlxuICAgICAgYXV0aEhhbmRsZXJUeXBlID0gSnd0QXV0aGVudGljYXRpb247XG4gICAgICBicmVhaztcbiAgICBjYXNlIEF1dGhUeXBlLk9QRU5fSUQ6XG4gICAgICBhdXRoSGFuZGxlclR5cGUgPSBPcGVuSWRBdXRoZW50aWNhdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQXV0aFR5cGUuU0FNTDpcbiAgICAgIGF1dGhIYW5kbGVyVHlwZSA9IFNhbWxBdXRoZW50aWNhdGlvbjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQXV0aFR5cGUuUFJPWFk6XG4gICAgICBhdXRoSGFuZGxlclR5cGUgPSBQcm94eUF1dGhlbnRpY2F0aW9uO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYXV0aGVudGljYXRpb24gdHlwZTogJHthdXRoVHlwZX1gKTtcbiAgfVxuICBjb25zdCBhdXRoOiBJQXV0aGVudGljYXRpb25UeXBlID0gY3JlYXRlQXV0aGVudGljYXRpb24oXG4gICAgYXV0aEhhbmRsZXJUeXBlLFxuICAgIGNvbmZpZyxcbiAgICBzZWN1cml0eVNlc3Npb25TdG9yYWdlRmFjdG9yeSxcbiAgICByb3V0ZXIsXG4gICAgZXNDbGllbnQsXG4gICAgY29yZSxcbiAgICBsb2dnZXJcbiAgKTtcbiAgcmV0dXJuIGF1dGg7XG59XG4iXX0=