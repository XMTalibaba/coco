"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setupIndexTemplate = setupIndexTemplate;
exports.migrateTenantIndices = migrateTenantIndices;

var _core = require("../../../../src/core/server/saved_objects/migrations/core");

var _build_index_map = require("../../../../src/core/server/saved_objects/migrations/core/build_index_map");

var _kibana_migrator = require("../../../../src/core/server/saved_objects/migrations/kibana/kibana_migrator");

/*
 *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *   Licensed under the Apache License, Version 2.0 (the "License").
 *   You may not use this file except in compliance with the License.
 *   A copy of the License is located at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *   or in the "license" file accompanying this file. This file is distributed
 *   on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *   express or implied. See the License for the specific language governing
 *   permissions and limitations under the License.
 */
async function setupIndexTemplate(esClient, kibanaIndex, typeRegistry, logger) {
  const mappings = (0, _core.buildActiveMappings)((0, _kibana_migrator.mergeTypes)(typeRegistry.getAllTypes()));

  try {
    await esClient.indices.putTemplate({
      name: 'tenant_template',
      body: {
        index_patterns: [kibanaIndex + '_-*_*', kibanaIndex + '_0*_*', kibanaIndex + '_1*_*', kibanaIndex + '_2*_*', kibanaIndex + '_3*_*', kibanaIndex + '_4*_*', kibanaIndex + '_5*_*', kibanaIndex + '_6*_*', kibanaIndex + '_7*_*', kibanaIndex + '_8*_*', kibanaIndex + '_9*_*'],
        settings: {
          number_of_shards: 1
        },
        mappings
      }
    });
  } catch (error) {
    logger.error(error);
    throw error;
  }
}

async function migrateTenantIndices(kibanaVersion, migrationClient, securityClient, typeRegistry, serializer, logger) {
  let tenentInfo;

  try {
    tenentInfo = await securityClient.getTenantInfoWithInternalUser();
  } catch (error) {
    logger.error(error);
    throw error;
  } // follows the same approach in kibana_migrator.ts to initiate DocumentMigrator here
  // see: https://tiny.amazon.com/foi0x1wt/githelaskibablobe4c1srccore


  const documentMigrator = new _core.DocumentMigrator({
    kibanaVersion,
    typeRegistry,
    log: logger
  });

  for (const indexName of Object.keys(tenentInfo)) {
    const indexMap = (0, _build_index_map.createIndexMap)({
      kibanaIndexName: indexName,
      indexMap: (0, _kibana_migrator.mergeTypes)(typeRegistry.getAllTypes()),
      registry: typeRegistry
    }); // follows the same aporach in kibana_mirator.ts to construct IndexMigrator
    // see: https://tiny.amazon.com/9cdcchz5/githelaskibablobe4c1srccore
    //
    // FIXME: hard code batchSize, pollInterval, and scrollDuration for now
    //        they are used to fetched from `migration.xxx` config, which is not accessible from new playform

    const indexMigrator = new _core.IndexMigrator({
      batchSize: 100,
      client: migrationClient,
      documentMigrator,
      index: indexName,
      log: logger,
      mappingProperties: indexMap[indexName].typeMappings,
      pollInterval: 1500,
      // millisec
      scrollDuration: '15m',
      serializer,
      obsoleteIndexTemplatePattern: undefined,
      convertToAliasScript: indexMap[indexName].script
    });

    try {
      await indexMigrator.migrate();
    } catch (error) {
      logger.error(error); // fail early, exit the kibana process
      // NOTE: according to https://github.com/elastic/kibana/issues/41983 ,
      //       PR https://github.com/elastic/kibana/pull/75819 , API to allow plugins
      //       to set status will be available in 7.10, for now, we fail Kibana
      //       process to indicate index migration error. Customer can fix their
      //       tenant indices in ES then restart Kibana.

      process.exit(1);
    }
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlbmFudF9pbmRleC50cyJdLCJuYW1lcyI6WyJzZXR1cEluZGV4VGVtcGxhdGUiLCJlc0NsaWVudCIsImtpYmFuYUluZGV4IiwidHlwZVJlZ2lzdHJ5IiwibG9nZ2VyIiwibWFwcGluZ3MiLCJnZXRBbGxUeXBlcyIsImluZGljZXMiLCJwdXRUZW1wbGF0ZSIsIm5hbWUiLCJib2R5IiwiaW5kZXhfcGF0dGVybnMiLCJzZXR0aW5ncyIsIm51bWJlcl9vZl9zaGFyZHMiLCJlcnJvciIsIm1pZ3JhdGVUZW5hbnRJbmRpY2VzIiwia2liYW5hVmVyc2lvbiIsIm1pZ3JhdGlvbkNsaWVudCIsInNlY3VyaXR5Q2xpZW50Iiwic2VyaWFsaXplciIsInRlbmVudEluZm8iLCJnZXRUZW5hbnRJbmZvV2l0aEludGVybmFsVXNlciIsImRvY3VtZW50TWlncmF0b3IiLCJEb2N1bWVudE1pZ3JhdG9yIiwibG9nIiwiaW5kZXhOYW1lIiwiT2JqZWN0Iiwia2V5cyIsImluZGV4TWFwIiwia2liYW5hSW5kZXhOYW1lIiwicmVnaXN0cnkiLCJpbmRleE1pZ3JhdG9yIiwiSW5kZXhNaWdyYXRvciIsImJhdGNoU2l6ZSIsImNsaWVudCIsImluZGV4IiwibWFwcGluZ1Byb3BlcnRpZXMiLCJ0eXBlTWFwcGluZ3MiLCJwb2xsSW50ZXJ2YWwiLCJzY3JvbGxEdXJhdGlvbiIsIm9ic29sZXRlSW5kZXhUZW1wbGF0ZVBhdHRlcm4iLCJ1bmRlZmluZWQiLCJjb252ZXJ0VG9BbGlhc1NjcmlwdCIsInNjcmlwdCIsIm1pZ3JhdGUiLCJwcm9jZXNzIiwiZXhpdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFzQkE7O0FBTUE7O0FBQ0E7O0FBN0JBOzs7Ozs7Ozs7Ozs7OztBQWdDTyxlQUFlQSxrQkFBZixDQUNMQyxRQURLLEVBRUxDLFdBRkssRUFHTEMsWUFISyxFQUlMQyxNQUpLLEVBS0w7QUFDQSxRQUFNQyxRQUFzQixHQUFHLCtCQUFvQixpQ0FBV0YsWUFBWSxDQUFDRyxXQUFiLEVBQVgsQ0FBcEIsQ0FBL0I7O0FBQ0EsTUFBSTtBQUNGLFVBQU1MLFFBQVEsQ0FBQ00sT0FBVCxDQUFpQkMsV0FBakIsQ0FBNkI7QUFDakNDLE1BQUFBLElBQUksRUFBRSxpQkFEMkI7QUFFakNDLE1BQUFBLElBQUksRUFBRTtBQUNKQyxRQUFBQSxjQUFjLEVBQUUsQ0FDZFQsV0FBVyxHQUFHLE9BREEsRUFFZEEsV0FBVyxHQUFHLE9BRkEsRUFHZEEsV0FBVyxHQUFHLE9BSEEsRUFJZEEsV0FBVyxHQUFHLE9BSkEsRUFLZEEsV0FBVyxHQUFHLE9BTEEsRUFNZEEsV0FBVyxHQUFHLE9BTkEsRUFPZEEsV0FBVyxHQUFHLE9BUEEsRUFRZEEsV0FBVyxHQUFHLE9BUkEsRUFTZEEsV0FBVyxHQUFHLE9BVEEsRUFVZEEsV0FBVyxHQUFHLE9BVkEsRUFXZEEsV0FBVyxHQUFHLE9BWEEsQ0FEWjtBQWNKVSxRQUFBQSxRQUFRLEVBQUU7QUFDUkMsVUFBQUEsZ0JBQWdCLEVBQUU7QUFEVixTQWROO0FBaUJKUixRQUFBQTtBQWpCSTtBQUYyQixLQUE3QixDQUFOO0FBc0JELEdBdkJELENBdUJFLE9BQU9TLEtBQVAsRUFBYztBQUNkVixJQUFBQSxNQUFNLENBQUNVLEtBQVAsQ0FBYUEsS0FBYjtBQUNBLFVBQU1BLEtBQU47QUFDRDtBQUNGOztBQUVNLGVBQWVDLG9CQUFmLENBQ0xDLGFBREssRUFFTEMsZUFGSyxFQUdMQyxjQUhLLEVBSUxmLFlBSkssRUFLTGdCLFVBTEssRUFNTGYsTUFOSyxFQU9MO0FBQ0EsTUFBSWdCLFVBQUo7O0FBQ0EsTUFBSTtBQUNGQSxJQUFBQSxVQUFVLEdBQUcsTUFBTUYsY0FBYyxDQUFDRyw2QkFBZixFQUFuQjtBQUNELEdBRkQsQ0FFRSxPQUFPUCxLQUFQLEVBQWM7QUFDZFYsSUFBQUEsTUFBTSxDQUFDVSxLQUFQLENBQWFBLEtBQWI7QUFDQSxVQUFNQSxLQUFOO0FBQ0QsR0FQRCxDQVNBO0FBQ0E7OztBQUNBLFFBQU1RLGdCQUFnQixHQUFHLElBQUlDLHNCQUFKLENBQXFCO0FBQzVDUCxJQUFBQSxhQUQ0QztBQUU1Q2IsSUFBQUEsWUFGNEM7QUFHNUNxQixJQUFBQSxHQUFHLEVBQUVwQjtBQUh1QyxHQUFyQixDQUF6Qjs7QUFNQSxPQUFLLE1BQU1xQixTQUFYLElBQXdCQyxNQUFNLENBQUNDLElBQVAsQ0FBWVAsVUFBWixDQUF4QixFQUFpRDtBQUMvQyxVQUFNUSxRQUFRLEdBQUcscUNBQWU7QUFDOUJDLE1BQUFBLGVBQWUsRUFBRUosU0FEYTtBQUU5QkcsTUFBQUEsUUFBUSxFQUFFLGlDQUFXekIsWUFBWSxDQUFDRyxXQUFiLEVBQVgsQ0FGb0I7QUFHOUJ3QixNQUFBQSxRQUFRLEVBQUUzQjtBQUhvQixLQUFmLENBQWpCLENBRCtDLENBTy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsVUFBTTRCLGFBQWEsR0FBRyxJQUFJQyxtQkFBSixDQUFrQjtBQUN0Q0MsTUFBQUEsU0FBUyxFQUFFLEdBRDJCO0FBRXRDQyxNQUFBQSxNQUFNLEVBQUVqQixlQUY4QjtBQUd0Q0ssTUFBQUEsZ0JBSHNDO0FBSXRDYSxNQUFBQSxLQUFLLEVBQUVWLFNBSitCO0FBS3RDRCxNQUFBQSxHQUFHLEVBQUVwQixNQUxpQztBQU10Q2dDLE1BQUFBLGlCQUFpQixFQUFFUixRQUFRLENBQUNILFNBQUQsQ0FBUixDQUFvQlksWUFORDtBQU90Q0MsTUFBQUEsWUFBWSxFQUFFLElBUHdCO0FBT2xCO0FBQ3BCQyxNQUFBQSxjQUFjLEVBQUUsS0FSc0I7QUFTdENwQixNQUFBQSxVQVRzQztBQVV0Q3FCLE1BQUFBLDRCQUE0QixFQUFFQyxTQVZRO0FBV3RDQyxNQUFBQSxvQkFBb0IsRUFBRWQsUUFBUSxDQUFDSCxTQUFELENBQVIsQ0FBb0JrQjtBQVhKLEtBQWxCLENBQXRCOztBQWFBLFFBQUk7QUFDRixZQUFNWixhQUFhLENBQUNhLE9BQWQsRUFBTjtBQUNELEtBRkQsQ0FFRSxPQUFPOUIsS0FBUCxFQUFjO0FBQ2RWLE1BQUFBLE1BQU0sQ0FBQ1UsS0FBUCxDQUFhQSxLQUFiLEVBRGMsQ0FFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0ErQixNQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxDQUFiO0FBQ0Q7QUFDRjtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICAgQ29weXJpZ2h0IDIwMjAgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuXG4gKiAgIFlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqICAgQSBjb3B5IG9mIHRoZSBMaWNlbnNlIGlzIGxvY2F0ZWQgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgIG9yIGluIHRoZSBcImxpY2Vuc2VcIiBmaWxlIGFjY29tcGFueWluZyB0aGlzIGZpbGUuIFRoaXMgZmlsZSBpcyBkaXN0cmlidXRlZFxuICogICBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqICAgZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbiAqICAgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVsYXN0aWNzZWFyY2hDbGllbnQsXG4gIElTYXZlZE9iamVjdFR5cGVSZWdpc3RyeSxcbiAgTG9nZ2VyLFxuICBTYXZlZE9iamVjdHNTZXJpYWxpemVyLFxufSBmcm9tICcuLi8uLi8uLi8uLi9zcmMvY29yZS9zZXJ2ZXInO1xuaW1wb3J0IHsgSW5kZXhNYXBwaW5nIH0gZnJvbSAnLi4vLi4vLi4vLi4vc3JjL2NvcmUvc2VydmVyL3NhdmVkX29iamVjdHMvbWFwcGluZ3MnO1xuaW1wb3J0IHtcbiAgYnVpbGRBY3RpdmVNYXBwaW5ncyxcbiAgRG9jdW1lbnRNaWdyYXRvcixcbiAgSW5kZXhNaWdyYXRvcixcbiAgTWlncmF0aW9uRXNDbGllbnQsXG59IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb3JlL3NlcnZlci9zYXZlZF9vYmplY3RzL21pZ3JhdGlvbnMvY29yZSc7XG5pbXBvcnQgeyBjcmVhdGVJbmRleE1hcCB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb3JlL3NlcnZlci9zYXZlZF9vYmplY3RzL21pZ3JhdGlvbnMvY29yZS9idWlsZF9pbmRleF9tYXAnO1xuaW1wb3J0IHsgbWVyZ2VUeXBlcyB9IGZyb20gJy4uLy4uLy4uLy4uL3NyYy9jb3JlL3NlcnZlci9zYXZlZF9vYmplY3RzL21pZ3JhdGlvbnMva2liYW5hL2tpYmFuYV9taWdyYXRvcic7XG5pbXBvcnQgeyBTZWN1cml0eUNsaWVudCB9IGZyb20gJy4uL2JhY2tlbmQvb3BlbmRpc3Ryb19zZWN1cml0eV9jbGllbnQnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBJbmRleFRlbXBsYXRlKFxuICBlc0NsaWVudDogRWxhc3RpY3NlYXJjaENsaWVudCxcbiAga2liYW5hSW5kZXg6IHN0cmluZyxcbiAgdHlwZVJlZ2lzdHJ5OiBJU2F2ZWRPYmplY3RUeXBlUmVnaXN0cnksXG4gIGxvZ2dlcjogTG9nZ2VyXG4pIHtcbiAgY29uc3QgbWFwcGluZ3M6IEluZGV4TWFwcGluZyA9IGJ1aWxkQWN0aXZlTWFwcGluZ3MobWVyZ2VUeXBlcyh0eXBlUmVnaXN0cnkuZ2V0QWxsVHlwZXMoKSkpO1xuICB0cnkge1xuICAgIGF3YWl0IGVzQ2xpZW50LmluZGljZXMucHV0VGVtcGxhdGUoe1xuICAgICAgbmFtZTogJ3RlbmFudF90ZW1wbGF0ZScsXG4gICAgICBib2R5OiB7XG4gICAgICAgIGluZGV4X3BhdHRlcm5zOiBbXG4gICAgICAgICAga2liYW5hSW5kZXggKyAnXy0qXyonLFxuICAgICAgICAgIGtpYmFuYUluZGV4ICsgJ18wKl8qJyxcbiAgICAgICAgICBraWJhbmFJbmRleCArICdfMSpfKicsXG4gICAgICAgICAga2liYW5hSW5kZXggKyAnXzIqXyonLFxuICAgICAgICAgIGtpYmFuYUluZGV4ICsgJ18zKl8qJyxcbiAgICAgICAgICBraWJhbmFJbmRleCArICdfNCpfKicsXG4gICAgICAgICAga2liYW5hSW5kZXggKyAnXzUqXyonLFxuICAgICAgICAgIGtpYmFuYUluZGV4ICsgJ182Kl8qJyxcbiAgICAgICAgICBraWJhbmFJbmRleCArICdfNypfKicsXG4gICAgICAgICAga2liYW5hSW5kZXggKyAnXzgqXyonLFxuICAgICAgICAgIGtpYmFuYUluZGV4ICsgJ185Kl8qJyxcbiAgICAgICAgXSxcbiAgICAgICAgc2V0dGluZ3M6IHtcbiAgICAgICAgICBudW1iZXJfb2Zfc2hhcmRzOiAxLFxuICAgICAgICB9LFxuICAgICAgICBtYXBwaW5ncyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlncmF0ZVRlbmFudEluZGljZXMoXG4gIGtpYmFuYVZlcnNpb246IHN0cmluZyxcbiAgbWlncmF0aW9uQ2xpZW50OiBNaWdyYXRpb25Fc0NsaWVudCxcbiAgc2VjdXJpdHlDbGllbnQ6IFNlY3VyaXR5Q2xpZW50LFxuICB0eXBlUmVnaXN0cnk6IElTYXZlZE9iamVjdFR5cGVSZWdpc3RyeSxcbiAgc2VyaWFsaXplcjogU2F2ZWRPYmplY3RzU2VyaWFsaXplcixcbiAgbG9nZ2VyOiBMb2dnZXJcbikge1xuICBsZXQgdGVuZW50SW5mbzogYW55O1xuICB0cnkge1xuICAgIHRlbmVudEluZm8gPSBhd2FpdCBzZWN1cml0eUNsaWVudC5nZXRUZW5hbnRJbmZvV2l0aEludGVybmFsVXNlcigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICAvLyBmb2xsb3dzIHRoZSBzYW1lIGFwcHJvYWNoIGluIGtpYmFuYV9taWdyYXRvci50cyB0byBpbml0aWF0ZSBEb2N1bWVudE1pZ3JhdG9yIGhlcmVcbiAgLy8gc2VlOiBodHRwczovL3RpbnkuYW1hem9uLmNvbS9mb2kweDF3dC9naXRoZWxhc2tpYmFibG9iZTRjMXNyY2NvcmVcbiAgY29uc3QgZG9jdW1lbnRNaWdyYXRvciA9IG5ldyBEb2N1bWVudE1pZ3JhdG9yKHtcbiAgICBraWJhbmFWZXJzaW9uLFxuICAgIHR5cGVSZWdpc3RyeSxcbiAgICBsb2c6IGxvZ2dlcixcbiAgfSk7XG5cbiAgZm9yIChjb25zdCBpbmRleE5hbWUgb2YgT2JqZWN0LmtleXModGVuZW50SW5mbykpIHtcbiAgICBjb25zdCBpbmRleE1hcCA9IGNyZWF0ZUluZGV4TWFwKHtcbiAgICAgIGtpYmFuYUluZGV4TmFtZTogaW5kZXhOYW1lLFxuICAgICAgaW5kZXhNYXA6IG1lcmdlVHlwZXModHlwZVJlZ2lzdHJ5LmdldEFsbFR5cGVzKCkpLFxuICAgICAgcmVnaXN0cnk6IHR5cGVSZWdpc3RyeSxcbiAgICB9KTtcblxuICAgIC8vIGZvbGxvd3MgdGhlIHNhbWUgYXBvcmFjaCBpbiBraWJhbmFfbWlyYXRvci50cyB0byBjb25zdHJ1Y3QgSW5kZXhNaWdyYXRvclxuICAgIC8vIHNlZTogaHR0cHM6Ly90aW55LmFtYXpvbi5jb20vOWNkY2NoejUvZ2l0aGVsYXNraWJhYmxvYmU0YzFzcmNjb3JlXG4gICAgLy9cbiAgICAvLyBGSVhNRTogaGFyZCBjb2RlIGJhdGNoU2l6ZSwgcG9sbEludGVydmFsLCBhbmQgc2Nyb2xsRHVyYXRpb24gZm9yIG5vd1xuICAgIC8vICAgICAgICB0aGV5IGFyZSB1c2VkIHRvIGZldGNoZWQgZnJvbSBgbWlncmF0aW9uLnh4eGAgY29uZmlnLCB3aGljaCBpcyBub3QgYWNjZXNzaWJsZSBmcm9tIG5ldyBwbGF5Zm9ybVxuICAgIGNvbnN0IGluZGV4TWlncmF0b3IgPSBuZXcgSW5kZXhNaWdyYXRvcih7XG4gICAgICBiYXRjaFNpemU6IDEwMCxcbiAgICAgIGNsaWVudDogbWlncmF0aW9uQ2xpZW50LFxuICAgICAgZG9jdW1lbnRNaWdyYXRvcixcbiAgICAgIGluZGV4OiBpbmRleE5hbWUsXG4gICAgICBsb2c6IGxvZ2dlcixcbiAgICAgIG1hcHBpbmdQcm9wZXJ0aWVzOiBpbmRleE1hcFtpbmRleE5hbWVdLnR5cGVNYXBwaW5ncyxcbiAgICAgIHBvbGxJbnRlcnZhbDogMTUwMCwgLy8gbWlsbGlzZWNcbiAgICAgIHNjcm9sbER1cmF0aW9uOiAnMTVtJyxcbiAgICAgIHNlcmlhbGl6ZXIsXG4gICAgICBvYnNvbGV0ZUluZGV4VGVtcGxhdGVQYXR0ZXJuOiB1bmRlZmluZWQsXG4gICAgICBjb252ZXJ0VG9BbGlhc1NjcmlwdDogaW5kZXhNYXBbaW5kZXhOYW1lXS5zY3JpcHQsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGluZGV4TWlncmF0b3IubWlncmF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgLy8gZmFpbCBlYXJseSwgZXhpdCB0aGUga2liYW5hIHByb2Nlc3NcbiAgICAgIC8vIE5PVEU6IGFjY29yZGluZyB0byBodHRwczovL2dpdGh1Yi5jb20vZWxhc3RpYy9raWJhbmEvaXNzdWVzLzQxOTgzICxcbiAgICAgIC8vICAgICAgIFBSIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL2tpYmFuYS9wdWxsLzc1ODE5ICwgQVBJIHRvIGFsbG93IHBsdWdpbnNcbiAgICAgIC8vICAgICAgIHRvIHNldCBzdGF0dXMgd2lsbCBiZSBhdmFpbGFibGUgaW4gNy4xMCwgZm9yIG5vdywgd2UgZmFpbCBLaWJhbmFcbiAgICAgIC8vICAgICAgIHByb2Nlc3MgdG8gaW5kaWNhdGUgaW5kZXggbWlncmF0aW9uIGVycm9yLiBDdXN0b21lciBjYW4gZml4IHRoZWlyXG4gICAgICAvLyAgICAgICB0ZW5hbnQgaW5kaWNlcyBpbiBFUyB0aGVuIHJlc3RhcnQgS2liYW5hLlxuICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cbiAgfVxufVxuIl19